# 楽天仕様書 (Rakuten Logic Specification)

本ドキュメントは、「掲載状況確認アプリ」における楽天データ（CSV）の取り込み処理、正規化、およびステータス判定ロジックの詳細仕様について記述します。

楽天データは「SKU移行後」のフォーマットを前提としており、**親子関係（商品管理番号）とSKU（システム連携用SKU番号）** の関係性を整理した上で、掲載ステータスを判定します。

## 1. データ取り込みと前処理フロー (`app.py`)

CSV読み込みから、判定用の「代表データ」を作成するまでのプロセスです。

### 1-1. 必須列の検証
CSV読み込み時、以下の列が存在しない場合はエラーとして処理を中断します。

| カテゴリ | 必須列名 | 用途 |
|:---|:---|:---|
| **基本情報** | `商品管理番号（商品URL）` | 親子関係のグルーピングキー |
| | `商品番号` | デフォルトの識別コード |
| | `商品名` | 表示用名称 |
| **制御フラグ** | `倉庫指定` | 0:通常 / 1:倉庫 |
| | `サーチ表示` | 1:表示 / 0:非表示 |
| | `注文ボタン` | 1:可 / 0:不可 |
| **期間** | `販売期間指定（開始日時）` | - |
| | `販売期間指定（終了日時）` | - |
| **SKU情報** | `システム連携用SKU番号` | **真の返礼品コード**として使用 |
| | `SKU倉庫指定` | SKU単位の倉庫フラグ |
| | `在庫数` | - |

### 1-2. データの正規化（SKU情報のマージ）
SKU単位で出力される行情報を、メインの判定列に統合（上書き）します。これにより、SKU行を独立した1つの返礼品として扱えるようにします。

1.  **商品番号の統合**:
    * `システム連携用SKU番号` に値がある場合 ⇒ **`商品番号` 列をこの値で上書き**します。
    * 判定のキーは常に `商品番号` 列を使用することになります。
2.  **倉庫指定の統合**:
    * `SKU倉庫指定` に値がある場合 ⇒ **`倉庫指定` 列をこの値で上書き**します。

### 1-3. 親情報の補完（Fill-down）
SKU行（子）では、親商品（1行目）の情報が空欄になっている場合があるため、以下の処理でデータを埋めます。

* **グルーピングキー**: `商品管理番号（商品URL）`
* **処理**: 同一グループ内の **先頭行（親）** の値を、同グループ内の全行（子）にコピーします。
* **補完対象列**:
    * `商品名`
    * `サーチ表示`
    * `販売期間指定（開始日時）`
    * `販売期間指定（終了日時）`
    * `注文ボタン`

### 1-4. 重複排除と代表行の選定（ランキング処理）
1つの返礼品コード（正規化後の `商品番号`）に対し、複数の行が存在する場合（例：データ不整合や複数SKUの混在など）、**「最も販売中である可能性が高い有効な1行」** を残すためにソートを行います。

**ソート順序（優先順位）**

以下の順序でデータを並べ替え、**最上位の1行**を採用します。

| 順位 | 判定項目 | 並び順 | 意図 |
|:---:|:---|:---|:---|
| **1** | **SKU有無** | - | `システム連携用SKU番号`を持つ行を最優先（SKU移行対応） |
| **2** | **倉庫指定** | **昇順** (0優先) | `1`(倉庫) よりも `0`(通常販売) を優先して「公開中」判定させる |
| **3** | **サーチ表示** | **降順** (1優先) | `0`(非表示) よりも `1`(表示) を優先 |
| **4** | **注文ボタン** | **降順** (1優先) | `0`(不可) よりも `1`(可) を優先 |
| **5** | **販売開始日** | **昇順** (空・過去優先) | ①空欄（常時）<br>②過去日付（開始済）<br>③未来日付（未開始）<br>の順で優先 |
| **6** | **販売終了日** | **昇順** (空・未来優先) | ①空欄（無期限）<br>②未来日付（販売中）<br>③過去日付（終了済）<br>の順で優先 |
| **7** | **在庫数** | **降順** (多い順) | 在庫が多い行を優先 |

※ ソート実行後、`商品番号` で `drop_duplicates(keep='first')` を実行します。

---

## 2. ステータス判定ロジック (`status.py`)

前処理で抽出された「代表行」に対し、以下の順序でステータスを決定します。
※ 楽天の場合、単一行だけでなく、同じ `商品管理番号` を持つ「兄弟行（SKUグループ）」の情報も参照して判定を行います（フォールバック処理）。

### 判定フローチャート

1.  **未登録判定**
    * 親コード（`商品管理番号`）が特定できない場合 ⇒ **「未登録」**

2.  **倉庫判定**
    * 自身の `倉庫指定` が `1` の場合 ⇒ **「倉庫」**
    * **【フォールバック】** 自身が `0` でも、同一グループ内の他SKUに `倉庫指定=1` が存在する場合 ⇒ **「倉庫」** とみなす。

3.  **在庫判定**
    * 自身の `在庫数` が `0` の場合:
        * 同一グループ内に在庫がある別SKUが存在するか確認。
        * 存在する場合 ⇒ その在庫数を採用（在庫ありとみなす）。
        * 存在しない場合 ⇒ **「在庫0」**

4.  **非表示判定**
    * `サーチ表示` が `0`（または数値の `0.0`）の場合 ⇒ **「非表示」**

5.  **注文不可判定**
    * `注文ボタン` が `0` の場合 ⇒ **「注文不可」**

6.  **日付（期間）判定**
    * 開始・終了設定なし ⇒ **「公開中」**
    * 開始日が未来 ⇒ **「未受付」**
    * 終了日がなし（開始のみ設定） ⇒ **「公開中」**
    * 終了日が過去 ⇒ **「受付終了」**
    * それ以外 ⇒ **「公開中」**

---

## 3. 処理概念図 (Mermaid)

```mermaid
graph TD
    subgraph Import [1. データ前処理]
        A[CSV読み込み] --> B[データ補完<br>親情報を子SKUへコピー]
        B --> C{SKU情報あり?}
        C -- Yes --> D[商品番号 = システム連携用SKU番号<br>倉庫指定 = SKU倉庫指定<br>で上書き]
        C -- No --> E[値をそのまま使用]
        D --> F[ソート処理<br>倉庫(0) > 表示(1) > 注文(1) > 期間(有効) > 在庫(多)]
        E --> F
        F --> G[重複排除<br>商品番号単位で最上位の1行を採用]
    end

    subgraph Status [2. ステータス判定]
        G --> H{親コードなし?}
        H -- Yes --> I[未登録]
        H -- No --> J{倉庫指定=1?<br>or 兄弟SKUが倉庫?}
        J -- Yes --> K[倉庫]
        J -- No --> L{在庫=0?<br>and 兄弟SKUも在庫0?}
        L -- Yes --> M[在庫0]
        L -- No --> N{サーチ表示=0?}
        N -- Yes --> O[非表示]
        N -- No --> P{注文ボタン=0?}
        P -- Yes --> Q[注文不可]
        P -- No --> R{期間判定}
        R -- 期間外 --> S[未受付/受付終了]
        R -- 期間内 --> T[公開中]
    end